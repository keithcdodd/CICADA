function CICADA_3_QC(cleaned_dir, compare_file)
% Will compare QC of before and after CICADA, and compare to a compare file
% (8 parameter is standard)
% cleaned dir is a directory within the output_dir given in the first two
% scripts. This will be either the cleaned_auto dir or the cleaned_manual
% dir

fprintf('\n')
close all

cd(cleaned_dir)
cleaned_dir_info = dir(cleaned_dir);

% Grab files, check if they exist 
cicada_name = dir('*CICADA*nonagg*');
cicada_file = [cicada_name.folder, '/', cicada_name.name];
orig_file = [cleaned_dir, '/../funcfile.nii.gz'];

% catch if there is no compare_file
if ~exist('compare_file', 'var') || strcmp(compare_file, 'x')
    fprintf('Will compare to standard 8 parameter \n')
    compare_file_info = dir('*8p*');
    compare_file=[compare_file_info.folder, '/', compare_file_info.name]; % Give it default 8p to compare against
end


if ~isfile(compare_file)
    fprintf(['ERROR, cannot find compare file: ', compare_file, '\n'])
elseif ~isfile(orig_file)
    fprintf('ERROR, cannot find orig file: funcfile.nii.gz \n')
elseif ~isfile(cicada_file)
    fprintf(['ERROR, cannot find CICADA file: ', cicada_name.name, '\n'])
end

cicada_data = niftiread(cicada_file);
orig_data = niftiread(orig_file);
compare_data = niftiread(compare_file);

orig_info = niftiinfo(orig_file);
tr=orig_info.PixelDimensions(4);
cleaned_dir_name = cleaned_dir_info.folder;

% check if comparing auto or manual, can base this off of cleaned dir name
if contains(cleaned_dir_name, 'manual')
    if isfile([cleaned_dir, '/../ic_manual_selection/DecisionVariables_Manual.mat'])
        load([cleaned_dir, '/../ic_manual_selection/DecisionVariables_Manual.mat'])
        ic_select = 'manual';
    else
        fprintf('Cannot find ../ic_manual_selection/DecisionVariables_Manual.mat \n')
        return
    end
else
    if isfile([cleaned_dir, '/../ic_auto_selection/DecisionVariables_Auto.mat'])
        load([cleaned_dir, '/../ic_auto_selection/DecisionVariables_Auto.mat']) %#ok<LOAD> 
        ic_select = 'auto';
    else
        fprintf('Cannot find ../ic_auto_selection/DecisionVariables_Auto.mat \n')
        return
    end
end


% calculate final estimation of DOF - probably want > 15 DOF, and/or at
% least 10% of percent_variance_kept from CICADA
% something to keep in mind is that you should actually calculate the power
% percentage being removed to be much more accurate - need to find the
% power fraction of bp from the data that has been cleaned by CICADA
% without frequency filtering thus far. Would use cicada_name.name without
% choice tag. Do later to improve this system.
DOF_estimate_final = Data.numvolumes .* Results.percent_variance_kept; %#ok<NODEF,USENS> 
Results.num_ICs_kept = length(Results.signal_ICs);
Results.num_ICs_total = length(Results.ICs);
fprintf(['Estimate of Final DOF for ', cicada_name.name, ' is %.2f\n'], DOF_estimate_final)

% confounds: So, overall you want/need the 6 motion parameters, dvars,
% framewise displacement, csf, white_matter, and global signal
confound_place = [cleaned_dir, '/../confounds_timeseries.csv'];
allconfounds = readtable(confound_place);
confounds_dvars = table2array(allconfounds(:,{'dvars'}));
confounds_fd = table2array(allconfounds(:,{'framewise_displacement'}));

% Get GM prob mask and create GM mask and not GM mask for denoised
% and original files
GM_prob_file = [cleaned_dir, '/../region_masks/GM_prob.nii.gz'];
WMCSF_prob_file = [cleaned_dir, '/../region_masks/WMandCSF_mask.nii.gz'];
CSF_prob_file = [cleaned_dir, '/../region_masks/CSF_prob.nii.gz'];
Edge_prob_file = [cleaned_dir, '/../region_masks/Edge_prob.nii.gz'];
Outbrain_prob_file = [cleaned_dir, '/../region_masks/OutbrainOnly_prob.nii.gz'];
funcmask = [cleaned_dir, '/../funcmask.nii.gz'];
if isfile([cleaned_dir, '/../region_masks/Outbrain_prob.nii.gz']) == 1
    NotGM_prob_file = [cleaned_dir, '/../region_masks/Outbrain_prob.nii.gz']; % this is a better estimate if we calculated it
else
    NotGM_prob_file = [cleaned_dir, '/../region_masks/NotGMorWM_prob.nii.gz']; % Makes sure not including anything that could be signal, removes WM too
end

fprintf(['Running comparison of ', cicada_name.name, ' to ', dir(compare_file).name, '\n'])    

% Now, get data for NotGM, Edge, Outbrain, WMCSF, and CSF for denoised data
fprintf('Calculating Denoised Data\n')
[denoised_GM, denoised_NotGM, ~, denoised_GM_mean, ~, ~] = getData(cicada_data, funcmask, GM_prob_file, NotGM_prob_file);
[~, denoised_Edge, ~, ~, ~, ~] = getData(cicada_data, funcmask, GM_prob_file, Edge_prob_file);
[~, denoised_Outbrain, ~, ~, ~, ~] = getData(cicada_data, funcmask, GM_prob_file, Outbrain_prob_file);
[~, denoised_WMCSF, ~, ~, ~, ~] = getData(cicada_data, funcmask, GM_prob_file, WMCSF_prob_file);
[~, denoised_CSF, ~, ~, ~, ~] = getData(cicada_data, funcmask, GM_prob_file, CSF_prob_file);

% Now, get data for NotGM, Edge, Outbrain, WMCSF, and CSF for orig data
fprintf('Calculating Original Data\n')
[orig_GM, orig_NotGM, ~, orig_GM_mean, ~, ~] = getData(orig_data, funcmask, GM_prob_file, NotGM_prob_file);
[~, orig_Edge, ~, ~, ~, ~] = getData(orig_data, funcmask, GM_prob_file, Edge_prob_file);
[~, orig_Outbrain, ~, ~, ~, ~] = getData(orig_data, funcmask, GM_prob_file, Outbrain_prob_file);
[~, orig_WMCSF, ~, ~, ~, ~] = getData(orig_data, funcmask, GM_prob_file, WMCSF_prob_file);
[~, orig_CSF, ~, ~, ~, ~] = getData(orig_data, funcmask, GM_prob_file, CSF_prob_file);

% Now, get data for NotGM, Edge, Outbrain, WMCSF, and CSF for compared data
fprintf('Calculating Compare Data\n')
[compare_GM, compare_NotGM, ~, compare_GM_mean, ~, ~] = getData(compare_data, funcmask, GM_prob_file, NotGM_prob_file);
[~, compare_Edge, ~, ~, ~] = getData(compare_data, funcmask, GM_prob_file, Edge_prob_file);
[~, compare_Outbrain, ~, ~, ~, ~] = getData(compare_data, funcmask, GM_prob_file, Outbrain_prob_file);
[~, compare_WMCSF, ~, ~, ~, ~] = getData(compare_data, funcmask, GM_prob_file, WMCSF_prob_file);
[~, compare_CSF, ~, ~, ~, ~] = getData(compare_data, funcmask, GM_prob_file, CSF_prob_file);

% Now compute relevant correlations, and some others that we don't use, but
% one could make use of if they desired
fprintf('Calculating Relevant Correlations\n')

% create permutations for regions, subtract a little bit because sometimes
% something funky happens and the sizes do not fully align with Edge
% Voxels. Very close (probably related to thresholding values)
GM_randperm = randperm(size(orig_GM, 1));
NotGM_randperm = randperm(size(orig_NotGM, 1));
Outbrain_randperm = randperm(size(orig_Outbrain, 1));
Edge_randperm = randperm(size(orig_Edge, 1));
WMCSF_randperm = randperm(size(orig_WMCSF, 1));
CSF_randperm = randperm(size(orig_CSF, 1));

% NotGM: Want to be shifted tighter and closer to 0
denoised_GM_NotGM_corr = createHistData(denoised_GM, denoised_NotGM, GM_randperm, NotGM_randperm, 500);
compare_GM_NotGM_corr = createHistData(compare_GM, compare_NotGM, GM_randperm, NotGM_randperm, 500);
orig_GM_NotGM_corr = createHistData(orig_GM, orig_NotGM, GM_randperm, NotGM_randperm, 500);

% GM: But, we want to maintain GM correlations in comparison (after other is removed)
% this one we compare to the original data, to see how much GM is
% maintained (want bad stuff removed, but not good stuff too!)
denoised_GM_GM_corr = createHistData(denoised_GM, orig_GM, GM_randperm, GM_randperm, 500);
compare_GM_GM_corr = createHistData(compare_GM, orig_GM, GM_randperm, GM_randperm, 500);

% Edge
denoised_GM_Edge_corr = createHistData(denoised_GM, denoised_Edge, GM_randperm, Edge_randperm, 500);
compare_GM_Edge_corr = createHistData(compare_GM, compare_Edge, GM_randperm, Edge_randperm, 500);
orig_GM_Edge_corr = createHistData(orig_GM, orig_Edge, GM_randperm, Edge_randperm, 500);

% Outbrain
denoised_GM_Outbrain_corr = createHistData(denoised_GM, denoised_Outbrain, GM_randperm, Outbrain_randperm, 500);
compare_GM_Outbrain_corr = createHistData(compare_GM, compare_Outbrain, GM_randperm, Outbrain_randperm, 500);
orig_GM_Outbrain_corr = createHistData(orig_GM, orig_Outbrain, GM_randperm, Outbrain_randperm, 500);

% WMCSF
denoised_GM_WMCSF_corr = createHistData(denoised_GM, denoised_WMCSF, GM_randperm, WMCSF_randperm, 500);
compare_GM_WMCSF_corr = createHistData(compare_GM, compare_WMCSF, GM_randperm, WMCSF_randperm, 500);
orig_GM_WMCSF_corr = createHistData(orig_GM, orig_WMCSF, GM_randperm, WMCSF_randperm, 500);

% CSF
denoised_GM_CSF_corr = createHistData(denoised_GM, denoised_CSF, GM_randperm, CSF_randperm, 500);
compare_GM_CSF_corr = createHistData(compare_GM, compare_CSF, GM_randperm, CSF_randperm, 500);
orig_GM_CSF_corr = createHistData(orig_GM, orig_CSF, GM_randperm, CSF_randperm, 500);

% dvars
denoised_GM_dvars_corr = createHistConf1DData(denoised_GM, confounds_dvars, GM_randperm, 10000);
compare_GM_dvars_corr = createHistConf1DData(compare_GM, confounds_dvars, GM_randperm, 10000);
orig_GM_dvars_corr = createHistConf1DData(orig_GM, confounds_dvars, GM_randperm, 10000);

% fd
denoised_GM_fd_corr = createHistConf1DData(denoised_GM, confounds_fd, GM_randperm, 10000);
compare_GM_fd_corr = createHistConf1DData(compare_GM, confounds_fd, GM_randperm, 10000);
orig_GM_fd_corr = createHistConf1DData(orig_GM, confounds_fd, GM_randperm, 10000);


% Create QC folder (if it doesn't already exist)
if ~isfolder([cleaned_dir, '/../qc'])
    mkdir([cleaned_dir, '/../qc'])
end
delete([cleaned_dir, '/../qc/*']) % delete old files to save potential space
cd([cleaned_dir, '/../qc'])

% The trick for naming is to spit by _, find slot of CICADA, save that slot
% and then up to, but not including, the last slot 
cicada_splitting = split(cicada_name.name, '_');
compare_splitting = split(dir(compare_file).name, '_');

label_spot = find(strcmp(cicada_splitting, 'CICADA'));
prefix = strjoin(cicada_splitting(1:label_spot-1), '_');
cicada_tag = strjoin(cicada_splitting(label_spot:end-1), '_');
compare_tag = strjoin(compare_splitting(label_spot:end-1), '_');
orig_tag = 'orig';

qc_naming = [prefix, '_', ic_select, '_', cicada_tag, '_vs_', compare_tag]; 
qc_vals = [qc_naming, '_qc_vals.mat'];
qc_plots = [qc_naming, '_qc_plots.jpg'];

% save relevant plotting variables
fprintf('Saving Relevant QC Data\n')
title_string = [prefix, ': ', cicada_tag, ', ', compare_tag, ', & ', orig_tag];
save(qc_vals, 'orig_GM_NotGM_corr', 'compare_GM_NotGM_corr', 'denoised_GM_NotGM_corr', ...
     'compare_GM_GM_corr', 'denoised_GM_GM_corr', ...
     'orig_GM_Outbrain_corr', 'compare_GM_Outbrain_corr', 'denoised_GM_Outbrain_corr', ...
     'orig_GM_Edge_corr', 'compare_GM_Edge_corr', 'denoised_GM_Edge_corr', ...
     'orig_GM_WMCSF_corr', 'compare_GM_WMCSF_corr', 'denoised_GM_WMCSF_corr', ...
     'orig_GM_CSF_corr', 'compare_GM_CSF_corr', 'denoised_GM_CSF_corr', ...
     'orig_GM_dvars_corr', 'compare_GM_dvars_corr', 'denoised_GM_dvars_corr', ...
     'orig_GM_fd_corr', 'compare_GM_fd_corr', 'denoised_GM_fd_corr', ...
     'denoised_GM_mean', 'title_string', 'orig_tag', 'compare_tag', 'cicada_tag',...
     'ic_select', 'DOF_estimate_final', 'Results', 'tr', 'Data', 'Tables') %#ok<USENS> 

% Now, in the future, if you want to replot anything, you should have
% everything you need by loading the qc_values.mat file, and then run just
% the figure stuff below

fprintf('Creating Figures\n')
figure('Position', [50, 50, 2000, 900])
t = tiledlayout(3,3, 'Padding', 'compact', 'TileSpacing', 'compact');
title(t, title_string, 'Interpreter', 'none')

% GM_Edge corr: Want to see a tighter distribution, centered near
% 0, if original is significantly right shifted, want to see less
% of that
nexttile
hold on
title('Edge-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_Edge_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_Edge_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_Edge_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_fd corr: Want to see a shift toward center for denoised
% (removal of noise/sudden GS signal shift in GM). Suggests it
% is robust against overall movement.
nexttile
hold on
title('FD-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_fd_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_fd_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_fd_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_dvars corr: Want to see a shift toward center for denoised
% (removal of noise/sudden GS signal shift in GM). Suggests it
% is robust against global signal changes (including large
% movement)
nexttile
hold on
title('DVARS-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_dvars_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_dvars_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_dvars_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_Outbrain corr: Want to see a tighter distribution, centered near
% 0, if original is significantly right shifted, want to see less
% of that
nexttile
hold on
title('Outbrain-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_Outbrain_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_Outbrain_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_Outbrain_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_WMCSF corr: Want to see a tighter distribution, centered near
% 0, if original is significantly right shifted, want to see less
% of that
nexttile
hold on
title('WMCSF-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_WMCSF_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_WMCSF_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_WMCSF_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_CSF corr: Want to see a tighter distribution, centered near
% 0, if original is significantly right shifted, want to see less
% of that
nexttile
hold on
title('CSF-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_CSF_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_CSF_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_CSF_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_NotGM corr: Want to see a tighter distribution, centered near
% 0, if original is significantly right shifted, want to see less
% of that. Want to see the denoised and orig be significantly different
nexttile
hold on
title('NotGM-GM Corr ', 'Interpreter', 'none')
histogram(orig_GM_NotGM_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(compare_GM_NotGM_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
histogram(denoised_GM_NotGM_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
hold off

% GM_GM autocorr to orig: Want to see signal correlations maintained, in comparison to
% GM_NotGM corr, but still reduced (removed erroneous/global correlations).
% get color order right to match other plots
colorord = get(gca, 'colororder');

nexttile
hold on
title('GM-GM Auto Corr to Orig', 'Interpreter', 'none')
histogram(compare_GM_GM_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'EdgeColor', colorord(2,:), 'LineWidth', 1.5)
histogram(denoised_GM_GM_corr, 'Normalization', 'pdf', 'DisplayStyle', 'stairs', 'EdgeColor', colorord(3,:), 'LineWidth', 1.5)
legend('compare', 'CICADA', 'Interpreter', 'none')
hold off

% Plot GS changes before and after Denoising - it is easier to
% detrend it all first for comparison
nexttile
hold on
title('Mean GM Signal (Detrended)', 'Interpreter', 'none')
plot(detrend(orig_GM_mean,2), 'LineWidth', 1.5)
plot(detrend(compare_GM_mean,2), 'LineWidth', 1.5)
plot(detrend(denoised_GM_mean,2), 'LineWidth', 1.5)
legend('orig', 'compare', 'CICADA', 'Interpreter', 'none')
xlim([0, length(orig_GM_mean)])
hold off


fprintf('Saving Figure\n')
exportgraphics(t, qc_plots, 'Resolution', 300)

fprintf('\n')
end

%%
function [GM, region, Global_Signal, GM_Signal_mean, GM_var, region_var] = getData(funcfile_data, funcmask, GM_prob_file, region_prob_file)
% read in the niftis
region_prob_data = niftiread(region_prob_file);
gm_prob_data = niftiread(GM_prob_file);
func_data = funcfile_data;
funcmask_data = niftiread(funcmask);

gm_mask = logical(gm_prob_data > 0.75 & funcmask_data == 1);
region_mask = logical(region_prob_data > 0.75 & funcmask_data == 1);
func_mask = logical(funcmask_data == 1);

% Select the timeseries for GM and region and global signal
global_signal = zeros(sum(func_mask(:)), size(func_data, 4));
GM = zeros(sum(gm_mask(:)), size(func_data, 4));
region = zeros(sum(region_mask(:)), size(func_data, 4));
for j = 1:size(func_data, 4)
    curr_func = func_data(:,:,:,j);
    GM(:,j) = curr_func(gm_mask);
    region(:,j) = curr_func(region_mask);
    global_signal(:,j) = curr_func(func_mask);
end

GM = GM(GM(:,1) ~= 0, :);
region = region(region(:, 1) ~= 0, :);
Global_Signal = global_signal(global_signal(:, 1) ~= 0, :);

GM_var = var(GM, 0, 2); % variance of difference in time for GM)
region_var = var(region, 0, 2);

%Global_Signal_mean = mean(global_signal(global_signal(:, 1) ~= 0, :));
%Global_Signal_mean = Global_Signal_mean - mean(Global_Signal_mean);
GM_Signal_mean = mean(GM(GM(:,1) ~= 0, :));
GM_Signal_mean = GM_Signal_mean - mean(GM_Signal_mean);
end

function compare_orig_corr = createHistData(compare_GM, orig_region, GM_randperm, region_randperm, perms)
% Should center close to 0 (not globally correlated) if it's
% denoised (e.g., denoised lowered noise)
compare_orig_corr = corr(compare_GM(GM_randperm(1:perms), :)', orig_region(region_randperm(1:perms), :)');
compare_orig_corr = compare_orig_corr(tril(compare_orig_corr, -1) ~= 0);

% Should center above 0 (e.g., denoise did not remove true signal)
% GM_corr = corr(compare_GM(GM_randperm(1:perms), :)', compare_GM(GM_randperm(1:perms), :)');
% GM_GM_corr = GM_corr(tril(GM_corr, -1) ~= 0);
end

function [GM_conf1D_corr] = createHistConf1DData(GM, conf, GM_randperm, perms)
% This is for confounds that are calculated in the 1st derivative
% and absolute value (e.g., dvars, fd)
% corr conf vs GM diff abs: Should be reduced if denoised
% consider detrend() for GM, since that is what we do for script 2 to focus
% more on spikes, less on drift.
GM_conf1D_corr = corr(conf(2:end), abs(diff(GM(GM_randperm(1:perms), :)')))';
end